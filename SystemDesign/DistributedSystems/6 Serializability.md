# Serializability

- Serializability ensures that the result of concurrent transactions is equivalent to some serial execution of the same transactions.
- Execution of transactions is called a schedule.
- Types of serializability -
  - View Serializability - schedules read and write the same data values as a serial schedule.
  - Conflict Serializability - conflicting operations between transactions are ordered the same as in a serial schedule.
- Conflicting operations -
  - Belong to different transactions.
  - Operate on the same data item, with at least one being a write.
  - Types - read-write conflict, write-read conflict, write-write conflict.
- Determining conflict serializability -
  - Precedence graph - nodes represent transactions, edges represent conflicts.
  - Schedule is conflict serializable if precedence graph is acyclic.
- Generating serializable schedules -
  - Prevent transactions from progressing if a conflict may form a cycle.
  - Allow transactions to execute, check for cycles at commit, abort and restart if necessary.
- Concurrency control mechanisms -
  - Pessimistic Concurrency Control - transactions acquire locks to prevent conflicts; assumes high likelihood of conflicts.
  - Optimistic Concurrency Control - check for conflicts at commit; abort and restart if needed; assumes low likelihood of conflicts.
- Trade-offs -
  - Pessimistic - overhead from locks, fewer aborts in high-conflict workloads.
  - Optimistic - minimal overhead during execution, may waste computation if transactions abort; performs well in low-conflict workloads (e.g., mostly read-only transactions).

## Pessimistic Concurrency Control (PCC) – 2-Phase Locking (2PL)

- 2-Phase Locking (2PL) uses locks to prevent concurrent transactions from interfering.
- Types of locks -
  - Write (exclusive) lock: acquired for insert/update/delete operations.
  - Read (shared) lock: acquired for read operations.
- Lock interactions -
  - Shared locks allow multiple reads simultaneously.
  - Shared lock blocks write until released.
  - Exclusive lock blocks both reads and writes.
  - Incompatible locks block each other; compatible locks do not.
- Locks prevent conflict cycles, ensuring conflict serializability.
- Phases of 2PL -
  - Expanding phase - transaction acquires locks but cannot release.
  - Shrinking phase - transaction releases locks but cannot acquire new ones.
  - Predicate locking - allows locking ranges of records to prevent anomalies like phantom reads.
- Schedule generated by 2PL is conflict equivalent to a serial schedule, with transactions serialized in the order they complete the expanding phase.
- Variations -
  - Strict 2PL (S2PL)
  - Strong Strict 2PL (SS2PL)
- Deadlocks - Occur when transactions wait on each other for locks, preventing progress.
- Handling deadlocks -
  - Prevention - acquire all required locks in a predefined order.
  - Detection - track waits-for graph, detect cycles, abort one transaction to resolve.

## Optimistic Concurrency Control (OCC)

- OCC allows transactions to execute without acquiring locks.
- Transactions execute in three phases -
  - Begin - assign a unique start timestamp to the transaction.
  - Read & Modify -
    - Read and write operations are performed tentatively.
    - Writes go to local temporary storage, reads first check this local copy.
  - Validate & Commit/Rollback -
    - Check for conflicts with transactions that started after the transaction’s start timestamp.
    - If conflicts exist, abort and restart with a new timestamp.
    - Otherwise, commit changes by copying local writes to the database atomically.
- Validation logic can be implemented in two ways -
  - Version Checking -
    - Track version numbers of data items during transaction.
    - Commit only if versions match (no intervening updates).
  - Timestamp Ordering -
    - Track read set and write set for each transaction.
    - Assign a finish timestamp at validation.
    - Check all transactions committed between start and finish timestamps.
    - If any committed transaction’s write set intersects current transaction’s read set, abort.
    - Otherwise, commit and assign next timestamp.
- Validation and commit must occur atomically (critical section).
- Optimizations reduce critical section duration to improve performance.

## Achieving Snapshot Isolation

- Multi-Version Concurrency Control (MVCC) maintains multiple physical versions for a single logical data item.
- Updates create new versions instead of overwriting existing records.
- Reads can select a specific version of a record, possibly an older one.
- MVCC can be combined with optimistic or pessimistic concurrency control, but typically uses optimistic methods.
- MVCC is commonly used to implement Snapshot Isolation (SI).
- Snapshot Isolation guarantees -
  - All reads in a transaction see a consistent snapshot of the database from when the transaction started.
  - Transaction commits successfully if no other transaction has updated the same data since that snapshot.
- Steps to achieve snapshot isolation using MVCC -
  - Assign a unique timestamp to each transaction at the beginning.
  - Every data item version is tagged with the timestamp of the transaction that created it.
- Each transaction records -
  - The highest committed timestamp at the start.
  - The set of active transactions that have started but not committed.
- Performing a read operation -
  - Return the latest version of an item that is earlier than the highest committed timestamp.
  - Ignore values from transactions that were active at the beginning of this transaction.
  - If the transaction already updated this item, return its own version.
  - This prevents dirty reads and fuzzy/non-repeatable reads.
- Performing a write operation -
  - Check if there exists an entry for the item that -
    - Has a version higher than this transaction’s timestamp, or
    - Has a version lower than this transaction’s timestamp but belongs to a transaction active at the beginning.
  - If either condition is true, abort and restart with a larger timestamp.
  - Prevents anomalies like lost updates.
- Limitations -
  - MVCC prevents many anomalies, but it is not fully serializable.
  - Write skew is still possible under snapshot isolation.
  - Transactions may not see a state that could occur in any serial execution.
- Example of write skew -
  - Two transactions read overlapping data sets concurrently.
  - Neither sees the uncommitted changes of the other.
  - Updates happen based on stale snapshots, causing inconsistencies that would not occur in a serial schedule.

## Achieving Full Serializable Snapshot Isolation

- Serializable Snapshot Isolation (SSI) is an optimistic concurrency control algorithm that extends snapshot isolation to achieve full serializability.
- It is integrated into commercial databases and prevents all anomalies, including write skew.
- Key principle -
  - All non-serializable executions under snapshot isolation share a common characteristic in their precedence graph.
  - There are two consecutive rw-dependency edges in a cycle involving concurrently active transactions.
- RW-dependency definition -
  - Transaction `T0` reads a version of item `x`.
  - Transaction `T1` writes a version of `x` that is later in the version order than the version read by `T0`.
  - This forms a data dependency edge from `T0` to `T1`.
- SSI approach -
  - Track incoming and outgoing rw-dependency edges for each transaction.
  - If a transaction has both incoming and outgoing edges, abort one of the transactions and retry later.
  - This may lead to false positive aborts but avoids expensive cycle detection computations.
- Implementation details -
  - Maintain two Boolean flags per transaction - `T.inConflict` and `T.outConflict`.
  - When a transaction reads an item, it detects if a later version exists from another transaction -
    - Update `T.outConflict` and the other transaction's `inConflict` to `true`.
  - Use `SIREAD` locks when reading items -
    - `SIREAD` locks signal data dependencies without blocking other transactions.
    - When a transaction writes an item, it checks `SIREAD` locks to detect concurrent reads and updates conflict flags.
  - The algorithm remains optimistic since locks do not block operations.
- Preventing write skew -
  - Transactions check `SIREAD` locks on items before writing.
  - If both `inConflict` and `outConflict` flags for a transaction are `true`, abort the transaction.
  - This prevents write skew anomalies that occur under normal snapshot isolation.
- SSI preserves the benefits of snapshot isolation while providing full serializability.
